{"version":3,"sources":["schema.ts","ApolloSetup.tsx","Layout.tsx","PetStorePage.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["callBackend","a","requestOptions","method","body","baseUrl","path","query","headers","url","URLSearchParams","fetch","JSON","stringify","response","text","status","parse","Error","createSchema","createSchemaFromSwagger","swaggerSchema","createApolloClient","schema","ApolloClient","cache","InMemoryCache","link","SchemaLink","ApolloSetup","children","useState","type","state","setState","useEffect","client","message","fetchSchema","Layout","PetDetailsQuery","gql","PetsQuery","PetItem","pet","id","category","open","setOpen","useQuery","variables","petId","toString","skip","loading","error","data","onClick","e","preventDefault","name","tags","photoUrls","map","petDetailsToString","getPetById","petIdIsSafe","numberId","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","PetList","pets","filter","i","key","PetStorePage","findPetsByStatus","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"u7BAKeA,E,8EAAf,+CAAAC,EAAA,iEACEC,eAAkBC,EADpB,EACoBA,OAAQC,EAD5B,EAC4BA,KAAMC,EADlC,EACkCA,QAASC,EAD3C,EAC2CA,KAAMC,EADjD,EACiDA,MAAOC,EADxD,EACwDA,QAEhDC,EAHR,UAGiBJ,GAHjB,OAG2BC,EAH3B,YAGmC,IAAII,gBAAgBH,IAHvD,SAOyBI,MAAMF,EAAK,CAChCN,SACAK,QAAQ,EAAD,CACL,eAAgB,oBACbA,GAELJ,KAAMQ,KAAKC,UAAUT,KAbzB,cAOQU,EAPR,gBAgBqBA,EAASC,OAhB9B,UAgBQA,EAhBR,SAiBM,KAAOD,EAASE,QAAUF,EAASE,OAAS,KAjBlD,mDAmBaJ,KAAKK,MAAMF,IAnBxB,2DAqBaA,GArBb,cAwBQ,IAAIG,MAAJ,oBAAuBJ,EAASE,OAAhC,cAA4CD,IAxBpD,2D,sBA2BO,IAAMI,EAAe,SAACV,GAAD,OAC1BW,uBAAwB,CACtBC,cAAeZ,EACfT,iB,kCC1BJ,SAASsB,EAAmBC,GAC1B,OAAO,IAAIC,IAAa,CACtBC,MAAO,IAAIC,IACXC,KAAM,IAAIC,IAAW,CACnBL,aAsBC,IAAMM,EAAc,SAAC,GAAoC,IAAlCC,EAAiC,EAAjCA,SAAiC,EACnCC,mBAA2B,CACnDC,KAAM,YAFqD,mBACtDC,EADsD,KAC/CC,EAD+C,KAyB7D,OApBAC,qBAAU,WAAM,4CACd,4BAAAlC,EAAA,+EAEyBkB,EACnB,+CAHN,OAEUI,EAFV,OAKIW,EAAS,CACPF,KAAM,WACNI,OAAQd,EAAmBC,KAPjC,gDAUIW,EAAS,CACPF,KAAM,QACNK,QAAS,KAAEA,UAZjB,0DADc,uBAAC,WAAD,wBAiBdC,KACC,IAEKL,EAAMD,MACZ,IAAK,QACH,OAAO,6CAASC,EAAMI,SACxB,IAAK,UACH,OAAO,yDACT,IAAK,WACH,OAAO,kBAAC,IAAD,CAAgBD,OAAQH,EAAMG,QAASN,GAChD,QACE,OACE,wEAAoClB,KAAKC,UAAUoB,EAAO,KAAM,GAAhE,OC9DKM,EAAS,SAAC,GAAD,IAAGT,EAAH,EAAGA,SAAH,OACpB,oCACE,wCACCA,I,geCCL,IAAMU,EAAkBC,IAAH,KAYfC,EAAYD,IAAH,KA4Bf,IAAME,EAAU,SAAC,GAAqD,IAAD,IAAlDC,IAAOC,EAA2C,EAA3CA,GAAIC,EAAuC,EAAvCA,SAAU9B,EAA6B,EAA7BA,OAA6B,EAC3Ce,oBAAkB,GADyB,mBAC5DgB,EAD4D,KACtDC,EADsD,KAEnE,IAAKH,EACH,MAAM,IAAI3B,MAAJ,sCAAyC2B,EAAzC,MAH2D,MAKlCI,YAC/BT,EACA,CACEU,UAAW,CACTC,MAAON,EAAGO,YAEZC,MAAON,IANHO,EAL2D,EAK3DA,QAASC,EALkD,EAKlDA,MAAOC,EAL2C,EAK3CA,KASxB,OACE,4BACE,4BACEC,QAAS,SAAAC,GACPA,EAAEC,iBACFX,GAASD,KAGVF,EANH,KAMS7B,EANT,IAOG8B,GAAYA,EAASc,MAArB,qBAA2Cd,EAASc,OAEtDb,IACEO,EACC,qDACEC,EACF,kDAAwBA,EAAMlB,SAC5BmB,EACF,6BA/CV,YAA+E,IAAjDI,EAAgD,EAAhDA,KAAMC,EAA0C,EAA1CA,KAAMC,EAAoC,EAApCA,UACxC,OAAOlD,KAAKC,UACV,CACE+C,OACAC,KAAMA,GAAQA,EAAKE,KAAI,qBAAGH,QAC1BE,aAEF,KACA,GAuCYE,CAAmBR,EAAKS,aAE9B,iDAAuBrD,KAAKC,UAAU2C,OAMhD,SAASU,EAAT,GAAyD,IAAlCrB,EAAiC,EAAjCA,GACrB,IAAKA,EACH,MAAM,IAAI3B,MAAJ,sCAAyC2B,EAAzC,MAER,IAAIsB,EAAWC,OAAOvB,GACtB,OACEuB,OAAOC,kBAAoBF,GAAYA,GAAYC,OAAOE,iBAQ9D,IAAMC,EAAU,SAAC,GAAD,IAAGC,EAAH,EAAGA,KAAH,OACd,4BACGA,EAAKC,OAAOP,GAAaH,KAAI,SAACnB,EAAK8B,GAAN,OAC5B,kBAAC,EAAD,CAASC,IAAKD,EAAG9B,IAAKA,SAKfgC,EAAe,WAAO,IAAD,EACC3B,YAA8BP,GAAvDY,EADwB,EACxBA,QAASC,EADe,EACfA,MAAOC,EADQ,EACRA,KACxB,OAAOF,EACL,uDACEC,EACF,2DAAuBA,EAAMlB,SAC3BmB,EACF,kBAAC,EAAD,CAASgB,KAAMhB,EAAKqB,mBAEpB,wEC3GWC,EARH,kBACV,kBAAC,EAAD,KACE,kBAAC,EAAD,KACE,kBAAC,EAAD,SCGcC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SDmI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,iB","file":"static/js/main.7663ec17.chunk.js","sourcesContent":["import {\n  createSchema as createSchemaFromSwagger,\n  CallBackendArguments,\n} from 'swagger-to-graphql';\n\nasync function callBackend({\n  requestOptions: { method, body, baseUrl, path, query, headers },\n}: CallBackendArguments<{}>) {\n  const url = `${baseUrl}${path}?${new URLSearchParams(query as Record<\n    string,\n    string\n  >)}`;\n  const response = await fetch(url, {\n    method,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: JSON.stringify(body),\n  });\n\n  const text = await response.text();\n  if (200 <= response.status && response.status < 300) {\n    try {\n      return JSON.parse(text);\n    } catch (e) {\n      return text;\n    }\n  }\n  throw new Error(`Response: ${response.status} - ${text}`);\n}\n\nexport const createSchema = (url: string) =>\n  createSchemaFromSwagger({\n    swaggerSchema: url,\n    callBackend,\n  });\n","import React, { ReactNode, useEffect, useState } from 'react';\nimport './App.css';\nimport { createSchema } from './schema';\nimport { ApolloProvider } from '@apollo/react-hooks';\nimport { GraphQLSchema } from 'graphql';\nimport { ApolloClient } from 'apollo-client';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport SchemaLink from 'apollo-link-schema';\n\nfunction createApolloClient(schema: GraphQLSchema) {\n  return new ApolloClient({\n    cache: new InMemoryCache(),\n    link: new SchemaLink({\n      schema,\n    }),\n  });\n}\n\ntype ApolloSetupState =\n  | {\n      type: 'loading';\n    }\n  | {\n      type: 'error';\n      message: string;\n    }\n  | {\n      type: 'resolved';\n      client: ReturnType<typeof createApolloClient>;\n    };\n\ninterface ApolloSetupProps {\n  children: ReactNode;\n}\n\nexport const ApolloSetup = ({ children }: ApolloSetupProps) => {\n  const [state, setState] = useState<ApolloSetupState>({\n    type: 'loading',\n  });\n\n  useEffect(() => {\n    async function fetchSchema() {\n      try {\n        const schema = await createSchema(\n          'https://petstore.swagger.io/v2/swagger.json',\n        );\n        setState({\n          type: 'resolved',\n          client: createApolloClient(schema),\n        });\n      } catch (e) {\n        setState({\n          type: 'error',\n          message: e.message,\n        });\n      }\n    }\n    fetchSchema();\n  }, []);\n\n  switch (state.type) {\n    case 'error':\n      return <>Error {state.message}</>;\n    case 'loading':\n      return <>Loading schema...</>;\n    case 'resolved':\n      return <ApolloProvider client={state.client}>{children}</ApolloProvider>;\n    default:\n      return (\n        <>Expected a different state than \"{JSON.stringify(state, null, 2)}\"</>\n      );\n  }\n};\n","import React, { ReactNode } from 'react';\nimport './App.css';\n\ninterface LayoutProps {\n  children: ReactNode;\n}\n\nexport const Layout = ({ children }: LayoutProps) => (\n  <>\n    <h1>PetStore</h1>\n    {children}\n  </>\n);\n","import React, { useState } from 'react';\nimport './App.css';\nimport gql from 'graphql-tag';\nimport { useQuery } from '@apollo/react-hooks';\nimport { FindPets, FindPets_findPetsByStatus } from './__generated__/FindPets';\nimport {\n  PetDetails,\n  PetDetails_getPetById,\n  PetDetailsVariables,\n} from './__generated__/PetDetails';\n\nconst PetDetailsQuery = gql`\n  query PetDetails($petId: String!) {\n    getPetById(petId: $petId) {\n      name\n      tags {\n        name\n      }\n      photoUrls\n    }\n  }\n`;\n\nconst PetsQuery = gql`\n  query FindPets {\n    findPetsByStatus(status: [\"available\", \"pending\"]) {\n      id\n      category {\n        name\n      }\n      status\n    }\n  }\n`;\n\nfunction petDetailsToString({ name, tags, photoUrls }: PetDetails_getPetById) {\n  return JSON.stringify(\n    {\n      name,\n      tags: tags && tags.map(({ name }) => name),\n      photoUrls,\n    },\n    null,\n    2,\n  );\n}\n\ninterface PetItemProps {\n  pet: FindPets_findPetsByStatus;\n}\n\nconst PetItem = ({ pet: { id, category, status } }: PetItemProps) => {\n  const [open, setOpen] = useState<boolean>(false);\n  if (!id) {\n    throw new Error(`Pet should have an id got: \"${id}\"`);\n  }\n  const { loading, error, data } = useQuery<PetDetails, PetDetailsVariables>(\n    PetDetailsQuery,\n    {\n      variables: {\n        petId: id.toString(),\n      },\n      skip: !open,\n    },\n  );\n  return (\n    <li>\n      <button\n        onClick={e => {\n          e.preventDefault();\n          setOpen(!open);\n        }}\n      >\n        {id} ({status})\n        {category && category.name && ` category: ${category.name}`}\n      </button>\n      {open &&\n        (loading ? (\n          <p>Loading pet details...</p>\n        ) : error ? (\n          <p>Error loading pets: {error.message}</p>\n        ) : data ? (\n          <pre>{petDetailsToString(data.getPetById)}</pre>\n        ) : (\n          <p>Expected data, got {JSON.stringify(data)}</p>\n        ))}\n    </li>\n  );\n};\n\nfunction petIdIsSafe({ id }: FindPets_findPetsByStatus) {\n  if (!id) {\n    throw new Error(`Pet should have an id got: \"${id}\"`);\n  }\n  let numberId = Number(id);\n  return (\n    Number.MIN_SAFE_INTEGER <= numberId && numberId <= Number.MAX_SAFE_INTEGER\n  );\n}\n\ninterface PetListProps {\n  pets: FindPets_findPetsByStatus[];\n}\n\nconst PetList = ({ pets }: PetListProps) => (\n  <ul>\n    {pets.filter(petIdIsSafe).map((pet, i) => (\n      <PetItem key={i} pet={pet} />\n    ))}\n  </ul>\n);\n\nexport const PetStorePage = () => {\n  const { loading, error, data } = useQuery<FindPets, undefined>(PetsQuery);\n  return loading ? (\n    <>Loading pets...</>\n  ) : error ? (\n    <>Error loading pets: {error.message}</>\n  ) : data ? (\n    <PetList pets={data.findPetsByStatus} />\n  ) : (\n    <>Expected error, loading or data</>\n  );\n};\n","import React from 'react';\nimport './App.css';\nimport { ApolloSetup } from './ApolloSetup';\nimport { Layout } from './Layout';\nimport { PetStorePage } from './PetStorePage';\n\nconst App = () => (\n  <Layout>\n    <ApolloSetup>\n      <PetStorePage />\n    </ApolloSetup>\n  </Layout>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}